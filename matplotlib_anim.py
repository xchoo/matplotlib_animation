from collections import Iterable

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation


def is_iterable_and_not_str(obj):
    return isinstance(obj, Iterable) and not isinstance(obj, str)


class MatplotlibAnim(object):
    '''
        data_gen_func:
            Reference to generator function used to generate data.
            Generator function must yield t, and data dictionary.
            Keys in the data dictionary should be identical to the keys used
            in subplot_data_dict (i.e. data_dict[KEY] should contain the data
            for the subplot specified by subplot_data_dict[KEY]).

            The data_gen_func should yield data as a tuple in the format:

            (t_data, data_dict)

            where data_dict is a tuple of lists (or arrays) containing the
            graph x and y data.
        subplot_shape:
            Shape (number of cells -- rows x cols) of the subplot grid.
        subplot_data_dict:
            Dictionary of dictionaries with configuration settings for each
            subplot in the subplot grid. The key value of the top-level
            dictionary correspondes to the key values in the data dictionary
            generated by the data_gen_func.

            The second-level dictionary contains configuration information for
            each subplot, configured as such:

            ('tl_loc': tuple specifying the grid location of the top-left
                       corner of the subplot,
             'br_loc': tuple specifying the grid location of the bottom-right
                       corner of the subplot (optional - defaults to value of
                       'tl_loc'),
             'setup_funcs':
             'init_args': other arguments to pass to plot function)

            For example, a 3D blue line with a line width=2 subplot spanning
            the entire second row of a 3 x 3 grid of subplots would be
            specified as:

            {'tl_loc': (1, 0), 'br_loc': (1, 2), 'dim': 3, 'color': 'b',
             'lw': 2}
    '''
    def __init__(self, data_gen_func, subplot_shape):
        self.data_gen_func = data_gen_func

        self.subplot_shape = subplot_shape
        self.subplot_data_dict = {}

        self.ax_dict = {}
        self.type_dict = {}
        self.line_dict = {}

        self.fig = plt.figure()

    def subplot_init(self, key, tl_loc, br_loc, plot_type):
        if key not in self.type_dict.keys():
            self.type_dict[key] = []
        elif plot_type in self.type_dict[key]:
            raise RuntimeError('matplotlib_anim.MatplotlibAnim: ' +
                               '"%s" type for key: [%s] already exists' %
                               (plot_type, key))

        if br_loc is None:
            br_loc = tl_loc

        plt.figure(self.fig.number)
        ax = plt.subplot2grid(self.subplot_shape, tl_loc,
                              rowspan=br_loc[0] - tl_loc[0] + 1,
                              colspan=br_loc[1] - tl_loc[1] + 1)
        self.ax_dict[key] = ax
        self.type_dict[key].append(plot_type)
        return ax

    # ----------------------------------------------------------------------- #
    def _add_plot_common(self, key, tl_loc, br_loc, dims, init_buffer_size,
                         autoscale_y, plot_type, **plot_args):
        ax = self.subplot_init(key, tl_loc, br_loc, plot_type)

        if init_buffer_size > 0:
            ax.set_xlim(0, init_buffer_size)

        self.subplot_data_dict[key] = {'type': plot_type,
                                       'dims': dims,
                                       'autoscale_y': autoscale_y}

        self.line_dict[key] = []
        for d in range(dims):
            line, = ax.plot([], [], **plot_args)
            self.line_dict[key].append(line)

        return ax

    def _plot_common_update(self, key, t_data, data, draw_artists):
        ax = self.ax_dict[key]
        plot_dim = self.subplot_data_dict[key]['dims']

        for d in range(plot_dim):
            self.line_dict[key][d].set_data(t_data, data[d])
            draw_artists.append(self.line_dict[key][d])

        if self.subplot_data_dict[key]['autoscale_y']:
            ax.relim()
            ax.autoscale_view(scalex=False, scaley=True)
            ax.figure.canvas.draw()

    # ----------------------------------------------------------------------- #
    def add_plot(self, key, tl_loc, br_loc=None, dims=1, init_buffer_size=0.5,
                 autoscale_y=False, **plot_args):
        return self._add_plot_common(key, tl_loc, br_loc, dims,
                                     init_buffer_size,
                                     autoscale_y, 'plot', **plot_args)

    def plot_update(self, key, t_data, data, draw_artists):
        ax = self.ax_dict[key]

        max_xlim = ax.get_xlim()[1]
        if max_xlim <= t_data[-1]:
            ax.set_xlim(ax.get_xlim()[0], max_xlim * 2)
            ax.figure.canvas.draw()

        self._plot_common_update(key, t_data, data, draw_artists)

    # ----------------------------------------------------------------------- #
    def add_plot_static_x(self, key, tl_loc, br_loc=None, dims=1,
                          autoscale_y=False, init_buffer_size=0.5, dt=0.001,
                          **plot_args):
        return self._add_plot_common(key, tl_loc, br_loc, dims,
                                     init_buffer_size, autoscale_y,
                                     'plot_static_x', **plot_args)

    def plot_static_x_update(self, key, t_data, data, draw_artists):
        ax = self.ax_dict[key]
        num_ticks = len(ax.xaxis.get_major_ticks())

        buffer_size = t_data[-1] - t_data[0]
        if ax.get_xlim()[1] < buffer_size:
            ax.set_xlim(0, buffer_size)

        t_max = max(ax.get_xlim()[1], t_data[-1])
        new_tick_labels = np.linspace(t_data[0], t_max, num=num_ticks,
                                      endpoint=True)
        ax.xaxis.set_ticklabels(map(lambda t: "%0.2f" % t, new_tick_labels))

        self._plot_common_update(key, t_data - t_data[0], data, draw_artists)

    # ----------------------------------------------------------------------- #
    def add_plot_scroll_x(self, key, tl_loc, br_loc=None, dims=1,
                          autoscale_y=False, init_buffer_size=0.5,
                          **plot_args):
        return self._add_plot_common(key, tl_loc, br_loc, dims,
                                     init_buffer_size, autoscale_y,
                                     'plot_scroll_x', **plot_args)

    def plot_scroll_x_update(self, key, t_data, data, draw_artists):
        ax = self.ax_dict[key]
        ax.set_xlim(t_data[0], max(t_data[-1], ax.get_xlim()[1]))
        ax.figure.canvas.draw()

        self._plot_common_update(key, t_data, data, draw_artists)

    # ----------------------------------------------------------------------- #
    def add_buffered_plot(self, key, tl_loc, br_loc=None, dims=1,
                          autoscale_y=False, buffer_size=500, **plot_args):
        ax = self._add_plot_common(key, tl_loc, br_loc, dims,
                                   buffer_size, autoscale_y, 'buffered_plot',
                                   **plot_args)
        self.subplot_data_dict[key]['data'] = [[] for _ in range(dims)]
        self.subplot_data_dict[key]['buffer_size'] = buffer_size
        ax.xaxis.set_ticklabels([])
        return ax

    def buffered_plot_update(self, key, t_data, data, draw_artists):
        ax = self.ax_dict[key]
        buffer_size = self.subplot_data_dict[key]['buffer_size']
        buffer_data = self.subplot_data_dict[key]['data']
        dims = self.subplot_data_dict[key]['dims']

        if len(t_data) > 3:
            num_ticks = len(ax.xaxis.get_major_ticks())
            dt = (t_data[-1] - t_data[1]) / (len(t_data) - 2)
            t_max = max(t_data[-1], dt * buffer_size)
            t_min = max(t_data[1], t_max - dt * buffer_size)

            new_tick_labels = np.linspace(t_min, t_max, num=num_ticks,
                                          endpoint=True)
            ax.xaxis.set_ticklabels(map(lambda t: "%0.2f" % t,
                                    new_tick_labels))

        for d in range(dims):
            buffer_data[d].append(data[d])
            buffer_data[d] = buffer_data[d][-buffer_size:]

        self._plot_common_update(key, range(buffer_size)[:len(buffer_data[0])],
                                 buffer_data, draw_artists)

    # ----------------------------------------------------------------------- #
    def add_imshow(self, key, tl_loc, br_loc=None, shape=None, **plot_args):
        plot_type = 'imshow'
        ax = self.subplot_init(key, tl_loc, br_loc, plot_type)

        if shape is None:
            raise RuntimeError('matplotlib_anim.MatplotlibAnim: ' +
                               'shape must be defined for "imshow" subplot. ' +
                               'Given %s, expected tuple.' % (str(shape)))

        self.subplot_data_dict[key] = {'type': plot_type,
                                       'shape': shape}

        init_matrix = np.zeros(shape)
        init_matrix[0] = 1
        line = ax.imshow(init_matrix, **plot_args)
        self.line_dict[key] = line

        ax.set_xticks([])
        ax.set_yticks([])

        return ax

    def imshow_update(self, key, t_data, data, draw_artists):
        im_data = np.reshape(data[:, -1],
                             self.subplot_data_dict[key]['shape'])
        self.line_dict[key].set_data(im_data)
        draw_artists.append(self.line_dict[key])

    # ----------------------------------------------------------------------- #
    def run_anim_func(self, data_from_func):
        t_data, data_dict = data_from_func

        draw_artists = []
        for key in data_dict.keys():
            for plot_type in self.type_dict[key]:
                getattr(self,
                        self.subplot_data_dict[key]['type'] +
                        '_update')(key, t_data, data_dict[key], draw_artists)

        return draw_artists

    def start(self, interval=30, **kwargs):
        self.fig.tight_layout()
        self.anim = animation.FuncAnimation(self.fig, self.run_anim_func,
                                            self.data_gen_func,
                                            interval=interval,
                                            **kwargs)
        plt.show()
