from collections import Iterable

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation


def is_iterable_and_not_str(obj):
    return isinstance(obj, Iterable) and not isinstance(obj, str)


# Helper function to reshape image data
def process_im_data(im_data, shape):
    is_fail = False

    if len(shape) > 2:
        # Process color images
        if shape[-1] == 3:
            return im_data.reshape(shape)
        elif shape[0] == 3:
            new_shape = (shape[1], shape[2], shape[0])
            return im_data.reshape(shape).T.reshape(new_shape).swapaxes(0, 1)
        else:
            is_fail = True
    elif len(shape) == 2:
        # Process BW images
        return im_data.reshape(shape)
    else:
        is_fail = True

    if is_fail:
        raise RuntimeError('PROCESS IM DATA: Unknown image shape: %s' %
                           str(shape))


# Helper function to get default cmap for image data:
def get_cmap(im_shape):
    if len(im_shape) > 2:
        return None
    else:
        return 'gray'


class MatplotlibAnim(object):
    '''
        data_gen_func:
            Reference to generator function used to generate data.
            Generator function must yield t, and data dictionary.
            Keys in the data dictionary should be identical to the keys used
            in subplot_data (i.e. data_dict[KEY] should contain the data
            for the subplot specified by subplot_data[KEY]).

            The data_gen_func should yield data as a tuple in the format:

            (t_data, data_dict)

            where data_dict is a tuple of lists (or arrays) containing the
            graph x and y data.
        subplot_shape:
            Shape (number of cells -- rows x cols) of the subplot grid.
        subplot_data:
            Dictionary of dictionaries with configuration settings for each
            subplot in the subplot grid. The key value of the top-level
            dictionary correspondes to the key values in the data dictionary
            generated by the data_gen_func.

            The second-level dictionary contains configuration information for
            each subplot, configured as such:

            ('tl_loc': tuple specifying the grid location of the top-left
                       corner of the subplot,
             'br_loc': tuple specifying the grid location of the bottom-right
                       corner of the subplot (optional - defaults to value of
                       'tl_loc'),
             'setup_funcs':
             'init_args': other arguments to pass to plot function)

            For example, a 3D blue line with a line width=2 subplot spanning
            the entire second row of a 3 x 3 grid of subplots would be
            specified as:

            {'tl_loc': (1, 0), 'br_loc': (1, 2), 'dim': 3, 'color': 'b',
             'lw': 2}
    '''
    # TODO: Make plots able to take axis as parameter
    #      Test plotting of multiple data points vs only those within limits
    #      Add 2D plot

    def __init__(self, data_gen_func, subplot_shape, fig=None):
        self.data_gen_func = data_gen_func

        self.subplot_shape = subplot_shape
        self.subplot_data = {}

        if fig is None:
            self.fig = plt.figure()
        else:
            self.fig = fig

    def subplot_key_check(self, key, plot_type):
        if key not in self.subplot_data.keys():
            self.subplot_data[key] = {}
        elif plot_type in self.subplot_data[key].keys():
            raise RuntimeError('matplotlib_anim.MatplotlibAnim: ' +
                               '"%s" type for key: [%s] already exists' %
                               (plot_type, key))
        self.subplot_data[key][plot_type] = {}

    def subplot_init(self, key, tl_loc, br_loc, plot_type):
        self.subplot_key_check(key, plot_type)

        if br_loc is None:
            br_loc = tl_loc

        plt.figure(self.fig.number)
        ax = plt.subplot2grid(self.subplot_shape, tl_loc,
                              rowspan=br_loc[0] - tl_loc[0] + 1,
                              colspan=br_loc[1] - tl_loc[1] + 1)
        self.subplot_data[key][plot_type]['ax'] = ax
        return ax

    # ----------------------------------------------------------------------- #
    def _add_plot_common(self, key, tl_loc, br_loc, dims, init_buffer_size,
                         autoscale_y, plot_type, ax, **plot_args):
        if ax is None:
            ax = self.subplot_init(key, tl_loc, br_loc, plot_type)
        else:
            # If ax is given, find subplot with matching ax and use that
            # buffer size instead
            done = False
            for k in self.subplot_data:
                for pt in self.subplot_data[k]:
                    if self.subplot_data[k][pt]['ax'] == ax:
                        init_buffer_size = \
                            self.subplot_data[k][pt]['buffer_size']
                        done = True
                if done:
                    break

            self.subplot_key_check(key, plot_type)
            self.subplot_data[key][plot_type]['ax'] = ax

        if init_buffer_size > 0:
            ax.set_xlim(0, init_buffer_size)

        self.subplot_data[key][plot_type]['autoscale_y'] = autoscale_y
        self.subplot_data[key][plot_type]['buffer_size'] = init_buffer_size
        self.subplot_data[key][plot_type]['dims'] = dims
        self.subplot_data[key][plot_type]['lines'] = []

        for d in range(dims):
            line, = ax.plot([], [], **plot_args)
            self.subplot_data[key][plot_type]['lines'].append(line)

        return ax

    def _plot_common_update(self, key, t_data, data, plot_type, draw_artists):
        subplot_data = self.subplot_data[key][plot_type]

        ax = subplot_data['ax']
        plot_dim = subplot_data['dims']

        for d in range(plot_dim):
            subplot_data['lines'][d].set_data(t_data, data[d])
            draw_artists.append(subplot_data['lines'][d])

        if subplot_data['autoscale_y']:
            ax.relim()
            ax.autoscale_view(scalex=False, scaley=True)
            ax.figure.canvas.draw()

    # ----------------------------------------------------------------------- #
    def add_plot(self, key, tl_loc=(0, 0), br_loc=None, dims=1,
                 init_buffer_size=0.5, autoscale_y=False, ax=None,
                 **plot_args):
        return self._add_plot_common(key, tl_loc, br_loc, dims,
                                     init_buffer_size,
                                     autoscale_y, 'plot', ax, **plot_args)

    def plot_update(self, key, t_data, data, draw_artists):
        ax = self.subplot_data[key]['plot']['ax']

        max_xlim = ax.get_xlim()[1]
        if max_xlim <= t_data[-1]:
            ax.set_xlim(ax.get_xlim()[0], max_xlim * 2)
            ax.figure.canvas.draw()

        self._plot_common_update(key, t_data, data, 'plot', draw_artists)

    # ----------------------------------------------------------------------- #
    def add_plot_static_x(self, key, tl_loc=(0, 0), br_loc=None, dims=1,
                          autoscale_y=False, buffer_size_s=0.5, ax=None,
                          **plot_args):
        if buffer_size_s < 0:
            raise RuntimeError('Buffer size (s) cannot be negative')
        return self._add_plot_common(key, tl_loc, br_loc, dims,
                                     buffer_size_s, autoscale_y,
                                     'plot_static_x', ax, **plot_args)

    def plot_static_x_update(self, key, t_data, data, draw_artists):
        subplot_data = self.subplot_data[key]['plot_static_x']

        ax = subplot_data['ax']
        num_ticks = len(ax.xaxis.get_major_ticks())

        buffer_size = subplot_data['buffer_size']
        t_min = max(t_data[0], t_data[-1] - buffer_size)
        t_max = max(ax.get_xlim()[1], t_data[-1])

        new_tick_labels = np.linspace(t_min, t_max, num=num_ticks,
                                      endpoint=True)
        ax.xaxis.set_ticklabels(map(lambda t: "%0.2f" % t, new_tick_labels))

        self._plot_common_update(key, t_data - t_min, data, 'plot_static_x',
                                 draw_artists)

    # ----------------------------------------------------------------------- #
    def add_plot_scroll_x(self, key, tl_loc=(0, 0), br_loc=None, dims=1,
                          autoscale_y=False, buffer_size_s=0.5,
                          ax=None, **plot_args):
        if buffer_size_s < 0:
            raise RuntimeError('Buffer size (s) cannot be negative')
        return self._add_plot_common(key, tl_loc, br_loc, dims,
                                     buffer_size_s, autoscale_y,
                                     'plot_scroll_x', ax, **plot_args)

    def plot_scroll_x_update(self, key, t_data, data, draw_artists):
        subplot_data = self.subplot_data[key]['plot_scroll_x']

        ax = subplot_data['ax']

        buffer_size = subplot_data['buffer_size']
        t_min = max(t_data[0], t_data[-1] - buffer_size)
        t_max = max(t_data[-1], ax.get_xlim()[1])

        ax.set_xlim(t_min, t_max)
        ax.figure.canvas.draw()

        self._plot_common_update(key, t_data, data, 'plot_scroll_x',
                                 draw_artists)

    # ----------------------------------------------------------------------- #
    def add_buffered_plot(self, key, tl_loc=(0, 0), br_loc=None, dims=1,
                          autoscale_y=False, buffer_size=500, ax=None,
                          **plot_args):
        ax = self._add_plot_common(key, tl_loc, br_loc, dims,
                                   buffer_size, autoscale_y, 'buffered_plot',
                                   ax, **plot_args)
        self.subplot_data[key]['buffered_plot']['data'] = \
            [[] for _ in range(dims)]
        ax.xaxis.set_ticklabels([])
        return ax

    def buffered_plot_update(self, key, t_data, data, draw_artists):
        subplot_data = self.subplot_data[key]['buffered_plot']

        ax = subplot_data['ax']

        buffer_size = subplot_data['buffer_size']
        buffer_data = subplot_data['data']
        dims = subplot_data['dims']

        if len(t_data) > 3:
            num_ticks = len(ax.xaxis.get_major_ticks())
            dt = (t_data[-1] - t_data[1]) / (len(t_data) - 2)
            t_max = max(t_data[-1], dt * buffer_size)
            t_min = max(t_data[1], t_max - dt * buffer_size)

            new_tick_labels = np.linspace(t_min, t_max, num=num_ticks,
                                          endpoint=True)
            ax.xaxis.set_ticklabels(map(lambda t: "%0.2f" % t,
                                    new_tick_labels))

        for d in range(dims):
            buffer_data[d].append(data[d])
            buffer_data[d] = buffer_data[d][-buffer_size:]

        self._plot_common_update(key, range(buffer_size)[:len(buffer_data[0])],
                                 buffer_data, 'buffered_plot', draw_artists)

    # ----------------------------------------------------------------------- #
    def add_imshow(self, key, tl_loc=(0, 0), br_loc=None, shape=None, ax=None,
                   cmap=plt.get_cmap('gray'), **plot_args):
        plot_type = 'imshow'

        if ax is None:
            ax = self.subplot_init(key, tl_loc, br_loc, plot_type)
        else:
            self.subplot_key_check(key, plot_type)
            self.subplot_data[key][plot_type]['ax'] = ax

        if shape is None:
            raise RuntimeError('matplotlib_anim.MatplotlibAnim: ' +
                               'shape must be defined for "imshow" subplot. ' +
                               'Given %s, expected tuple.' % (str(shape)))

        self.subplot_data[key][plot_type]['shape'] = shape

        plot_args.setdefault('cmap', get_cmap(shape))

        init_matrix = process_im_data(np.zeros(np.cumprod(shape)[-1]),
                                      shape)
        init_matrix[0] = 1
        line = ax.imshow(init_matrix, **plot_args)
        self.subplot_data[key][plot_type]['lines'] = line

        ax.set_xticks([])
        ax.set_yticks([])

        return ax

    def imshow_update(self, key, t_data, data, draw_artists):
        # im_data = np.reshape(data,
        #                      self.subplot_data[key]['imshow']['shape'])
        im_data = process_im_data(data,
                                  self.subplot_data[key]['imshow']['shape'])
        self.subplot_data[key]['imshow']['lines'].set_data(im_data)
        draw_artists.append(self.subplot_data[key]['imshow']['lines'])

    # ----------------------------------------------------------------------- #
    def add_plot2D(self, key, tl_loc=(0, 0), br_loc=None,
                   buffer_size_s=0.5, ax=None, **plot_args):
        ax = self._add_plot_common(key, tl_loc, br_loc, 1,
                                   buffer_size_s, False, 'plot2D',
                                   ax, **plot_args)
        ax.set_xlim(-1, 1)
        ax.set_ylim(-1, 1)
        ax.xaxis.grid()
        ax.yaxis.grid()
        ax.set_aspect(1)

        return ax

    def plot2D_update(self, key, t_data, data, draw_artists):
        subplot_data = self.subplot_data[key]['plot2D']

        x_data = None
        y_data = None

        buffer_size = subplot_data['buffer_size']
        if buffer_size < 0:
            t_min = t_data[0]
        else:
            t_min = max(t_data[0], t_data[-1] - buffer_size)

        valid_t_index = t_data > t_min
        x_data = data[0, valid_t_index]
        y_data = data[1, valid_t_index]

        subplot_data['lines'][0].set_data(x_data, y_data)
        draw_artists.append(subplot_data['lines'][0])

    # ----------------------------------------------------------------------- #
    def run_anim_func(self, data_from_func):
        t_data, data_dict = data_from_func

        draw_artists = []
        for key in data_dict.keys():
            if key in self.subplot_data:
                for plot_type in self.subplot_data[key].keys():
                    getattr(self, plot_type + '_update')(key, t_data,
                                                         data_dict[key],
                                                         draw_artists)

        return draw_artists

    def start(self, interval=30, **kwargs):
        if len(self.subplot_data) < 1:
            raise RuntimeError('Error: No plots have been added!')

        self.fig.tight_layout()
        self.anim = animation.FuncAnimation(self.fig, self.run_anim_func,
                                            self.data_gen_func,
                                            interval=interval,
                                            **kwargs)
        plt.show()
